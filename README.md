# Виртуальные функции
В этом разделе мы узнаем еще об одном механизме реализации полиморфизма в С++. До этого мы рассматривали так называемый статический полиморфизм. Т.е. мы выполняли перегрузку функций на основе типов, или с помощью шаблонов. В С++ также возможен другой подход к полиморфизму, динамический, который реализуеться спомощью виртуальных функций.
Пример
```cpp
#include <iostream>

class Base {
  public:
   void print() {
     std::cout << __PRETTY_FUNCTION__ << std::endl;
   }
};

class Derived: public Base {
  public:
   void print() {
     std::cout << __PRETTY_FUNCTION__ << std::endl;
   }
};

int main(int argc, char const *argv[]) {
  Derived d;
  Base& b = d;
  b.print();
  return 0;
}

```

Мы уже с вами рассматривали этот пример, т.е. у нас есть базовый класс, наследник и наследование между ними открытое. Благодаря открытому наследованию, объект базовго класса может ссылаться на подобъект базового класса в объекте наследника. Но при попытке вызвать метод, который есть и в базовом и производном, то мы вызовем метод базовго класса.
```
void Base::print()
```

Этот подход называеться ранним связыванием. Т.е. это означает что доступность вызова метода проверяетьлся во время компиляции на основе вызываемого объектом типа, а не на основе ссылающегося типа. Т.е. в нашем примере вызов метода `print` будет проверен компилятор на стадии копляции основываясь на тип `Base`, а не на тип Derived на который сылаеться объект базовго класса.

А хотелось бы чтобы имея например указатель или ссылку на базовый класс, динамически вызывать метод объекта на который ссылаеться объект базового класса. И такой подход в С++ реализован посредством виртуальный функций. Идея виртуальных функций есть как раз один интерфейс и разная реализация.
